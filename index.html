<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aura DDS Viewer</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='16' fill='%236c5ce7'/><text x='50' y='62' text-anchor='middle' font-size='40' font-weight='bold' fill='white' font-family='sans-serif'>DDS</text></svg>">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0d0d12;
            --bg-secondary: #16161e;
            --bg-tertiary: #1e1e2a;
            --bg-hover: #262636;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
            --text-dim: #55556a;
            --accent: #6c5ce7;
            --accent-light: #a29bfe;
            --accent-glow: rgba(108, 92, 231, 0.3);
            --border: #2a2a3c;
            --red: #ff6b6b;
            --green: #51cf66;
            --blue: #339af0;
            --alpha-checker: #2a2a2a;
            --radius: 12px;
            --radius-sm: 8px;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        /* ===== Header ===== */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        .header-title .icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: linear-gradient(135deg, var(--accent), #a29bfe);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .btn {
            padding: 7px 16px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: var(--accent-light);
        }

        /* ===== Toolbar ===== */
        .toolbar {
            display: flex;
            align-items: center;
            padding: 8px 24px;
            gap: 6px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .toolbar .separator {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 8px;
        }

        .channel-btn {
            padding: 5px 12px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            letter-spacing: 0.5px;
        }

        .channel-btn:hover {
            background: var(--bg-hover);
        }

        .channel-btn.active {
            color: #fff;
            border-color: transparent;
        }

        .channel-btn.active[data-channel="rgba"] {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }

        .channel-btn.active[data-channel="r"] {
            background: var(--red);
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.3);
        }

        .channel-btn.active[data-channel="g"] {
            background: var(--green);
            box-shadow: 0 0 10px rgba(81, 207, 102, 0.3);
        }

        .channel-btn.active[data-channel="b"] {
            background: var(--blue);
            box-shadow: 0 0 10px rgba(51, 154, 240, 0.3);
        }

        .channel-btn.active[data-channel="a"] {
            background: #888;
            box-shadow: 0 0 10px rgba(136, 136, 136, 0.3);
        }

        .info-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-left: auto;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .info-item .label {
            color: var(--text-dim);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .zoom-btn {
            width: 26px;
            height: 26px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .zoom-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .zoom-label {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 42px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        /* ===== Main Canvas Area ===== */
        .canvas-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        .canvas-area:active {
            cursor: grabbing;
        }

        .canvas-area.drag-over::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(108, 92, 231, 0.08);
            border: 2px dashed var(--accent);
            z-index: 10;
            pointer-events: none;
        }

        .canvas-wrapper {
            position: absolute;
            transform-origin: 0 0;
        }

        .checker-bg {
            background-image:
                linear-gradient(45deg, var(--alpha-checker) 25%, transparent 25%),
                linear-gradient(-45deg, var(--alpha-checker) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, var(--alpha-checker) 75%),
                linear-gradient(-45deg, transparent 75%, var(--alpha-checker) 75%);
            background-size: 16px 16px;
            background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
            background-color: #1a1a1a;
        }

        #dds-canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* ===== Drop Zone ===== */
        .drop-zone {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            z-index: 5;
        }

        .drop-zone.hidden {
            display: none;
        }

        .drop-icon {
            width: 80px;
            height: 80px;
            border-radius: 20px;
            background: var(--bg-tertiary);
            border: 2px dashed var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            transition: all 0.3s ease;
        }

        .canvas-area.drag-over .drop-icon {
            border-color: var(--accent);
            color: var(--accent);
            background: rgba(108, 92, 231, 0.1);
            transform: scale(1.05);
        }

        .drop-text {
            font-size: 15px;
            color: var(--text-secondary);
        }

        .drop-subtext {
            font-size: 12px;
            color: var(--text-dim);
        }

        /* ===== Mipmap selector ===== */
        .mip-select {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
        }

        /* ===== Scrollbar ===== */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        /* ===== Toggle ===== */
        .toggle-wrap {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .toggle {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--border);
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s;
        }

        .toggle.active::after {
            transform: translateX(14px);
        }
    </style>
</head>

<body>

    <!-- Header -->
    <div class="header">
        <div class="header-title">
            <div class="icon">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                    <circle cx="8.5" cy="8.5" r="1.5" />
                    <polyline points="21 15 16 10 5 21" />
                </svg>
            </div>
            <span>Aura DDS Viewer</span>
        </div>
        <div class="header-actions">
            <button class="btn btn-primary" id="btn-open">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />
                </svg>
                파일 열기
            </button>
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar" id="toolbar">
        <button class="channel-btn active" data-channel="rgba">RGBA</button>
        <button class="channel-btn" data-channel="r">R</button>
        <button class="channel-btn" data-channel="g">G</button>
        <button class="channel-btn" data-channel="b">B</button>
        <button class="channel-btn" data-channel="a">A</button>

        <div class="separator"></div>

        <div class="toggle-wrap">
            <div class="toggle active" id="toggle-checker"></div>
            <span>투명 배경</span>
        </div>

        <div class="separator"></div>

        <span style="font-size:12px; color: var(--text-dim);">Mip:</span>
        <select class="mip-select" id="mip-select">
            <option value="0">Level 0</option>
        </select>

        <div class="separator"></div>

        <div class="zoom-controls">
            <button class="zoom-btn" id="zoom-out">&minus;</button>
            <span class="zoom-label" id="zoom-label">100%</span>
            <button class="zoom-btn" id="zoom-in">+</button>
            <button class="zoom-btn" id="zoom-fit" title="화면에 맞추기">&#x229E;</button>
        </div>

        <div class="info-bar" id="info-bar">
            <div class="info-item">
                <span class="label">크기:</span>
                <span id="info-size">&mdash;</span>
            </div>
            <div class="info-item">
                <span class="label">포맷:</span>
                <span id="info-format">&mdash;</span>
            </div>
            <div class="info-item">
                <span class="label">Mips:</span>
                <span id="info-mips">&mdash;</span>
            </div>
            <div class="info-item">
                <span class="label">파일:</span>
                <span id="info-name">&mdash;</span>
            </div>
        </div>
    </div>

    <!-- Canvas Area -->
    <div class="canvas-area" id="canvas-area">
        <div class="drop-zone" id="drop-zone">
            <div class="drop-icon">
                <svg width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"
                    stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                    <circle cx="8.5" cy="8.5" r="1.5" />
                    <polyline points="21 15 16 10 5 21" />
                </svg>
            </div>
            <div class="drop-text">이미지 파일을 드래그하거나 클릭하여 열기</div>
            <div class="drop-subtext">DDS (DXT1/3/5) &middot; PNG &middot; JPG &middot; GIF &middot; BMP &middot; WebP
                &middot; TGA</div>
        </div>
        <div class="canvas-wrapper checker-bg" id="canvas-wrapper" style="display:none;">
            <canvas id="dds-canvas"></canvas>
            <img id="gif-img" style="display:none; width:100%; height:100%;">
        </div>
    </div>

    <input type="file" id="file-input" accept=".dds,.png,.jpg,.jpeg,.gif,.bmp,.webp,.tga,.tiff,.tif,.svg"
        style="display:none;">

    <script>
        // ========================================================
        // DDS Parser
        // ========================================================
        const DDS_MAGIC = 0x20534444;
        const DDPF_ALPHAPIXELS = 0x1;
        const DDPF_FOURCC = 0x4;
        const DDPF_RGB = 0x40;
        const FOURCC_DXT1 = 0x31545844;
        const FOURCC_DXT3 = 0x33545844;
        const FOURCC_DXT5 = 0x35545844;

        function parseDDS(buffer) {
            const view = new DataView(buffer);
            const magic = view.getUint32(0, true);
            if (magic !== DDS_MAGIC) throw new Error('유효하지 않은 DDS 파일입니다.');

            const headerSize = view.getUint32(4, true);
            if (headerSize !== 124) throw new Error('DDS 헤더 크기가 올바르지 않습니다.');

            const height = view.getUint32(12, true);
            const width = view.getUint32(16, true);
            const mipMapCount = Math.max(1, view.getUint32(28, true));

            const pfFlags = view.getUint32(80, true);
            const fourCC = view.getUint32(84, true);
            const rgbBitCount = view.getUint32(88, true);
            const rMask = view.getUint32(92, true);
            const gMask = view.getUint32(96, true);
            const bMask = view.getUint32(100, true);
            const aMask = view.getUint32(104, true);

            let format = 'unknown';
            if (pfFlags & DDPF_FOURCC) {
                if (fourCC === FOURCC_DXT1) format = 'DXT1';
                else if (fourCC === FOURCC_DXT3) format = 'DXT3';
                else if (fourCC === FOURCC_DXT5) format = 'DXT5';
                else format = 'FOURCC_0x' + fourCC.toString(16);
            } else if (pfFlags & DDPF_RGB) {
                if (rgbBitCount === 32) {
                    if (rMask === 0xFF && bMask === 0xFF0000) format = 'RGBA8';
                    else if (rMask === 0xFF0000 && bMask === 0xFF) format = 'BGRA8';
                    else format = 'RGBA32_CUSTOM';
                } else if (rgbBitCount === 24) {
                    format = 'RGB24';
                } else {
                    format = 'RGB_' + rgbBitCount + 'bit';
                }
            }

            const mipmaps = [];
            let offset = 128;

            for (let i = 0; i < mipMapCount; i++) {
                const mipW = Math.max(1, width >> i);
                const mipH = Math.max(1, height >> i);
                let dataSize;

                if (format === 'DXT1') {
                    dataSize = Math.max(1, Math.ceil(mipW / 4)) * Math.max(1, Math.ceil(mipH / 4)) * 8;
                } else if (format === 'DXT3' || format === 'DXT5') {
                    dataSize = Math.max(1, Math.ceil(mipW / 4)) * Math.max(1, Math.ceil(mipH / 4)) * 16;
                } else if (format === 'RGBA8' || format === 'BGRA8' || format === 'RGBA32_CUSTOM') {
                    dataSize = mipW * mipH * 4;
                } else if (format === 'RGB24') {
                    dataSize = mipW * mipH * 3;
                } else {
                    dataSize = mipW * mipH * Math.max(1, rgbBitCount / 8);
                }

                if (offset + dataSize > buffer.byteLength) break;

                mipmaps.push({
                    width: mipW, height: mipH,
                    data: new Uint8Array(buffer, offset, dataSize),
                    offset, size: dataSize,
                });
                offset += dataSize;
            }

            return { width, height, format, mipMapCount, mipmaps, pfFlags, rgbBitCount, rMask, gMask, bMask, aMask };
        }

        // ========================================================
        // DXT Decompression
        // ========================================================
        function unpackColor565(c) {
            return [
                ((c >> 11) & 0x1F) * 255 / 31 | 0,
                ((c >> 5) & 0x3F) * 255 / 63 | 0,
                (c & 0x1F) * 255 / 31 | 0,
                255
            ];
        }

        function decodeDXT1Block(src, off) {
            const c0 = src[off] | (src[off + 1] << 8);
            const c1 = src[off + 2] | (src[off + 3] << 8);
            const col0 = unpackColor565(c0);
            const col1 = unpackColor565(c1);
            const colors = [col0, col1, [0, 0, 0, 255], [0, 0, 0, 255]];

            if (c0 > c1) {
                colors[2] = [(2 * col0[0] + col1[0] + 1) / 3 | 0, (2 * col0[1] + col1[1] + 1) / 3 | 0, (2 * col0[2] + col1[2] + 1) / 3 | 0, 255];
                colors[3] = [(col0[0] + 2 * col1[0] + 1) / 3 | 0, (col0[1] + 2 * col1[1] + 1) / 3 | 0, (col0[2] + 2 * col1[2] + 1) / 3 | 0, 255];
            } else {
                colors[2] = [(col0[0] + col1[0]) / 2 | 0, (col0[1] + col1[1]) / 2 | 0, (col0[2] + col1[2]) / 2 | 0, 255];
                colors[3] = [0, 0, 0, 0];
            }

            const pixels = new Uint8Array(64);
            const bits = src[off + 4] | (src[off + 5] << 8) | (src[off + 6] << 16) | (src[off + 7] << 24);
            for (let i = 0; i < 16; i++) {
                const idx = (bits >> (i * 2)) & 0x3;
                const c = colors[idx];
                pixels[i * 4] = c[0]; pixels[i * 4 + 1] = c[1]; pixels[i * 4 + 2] = c[2]; pixels[i * 4 + 3] = c[3];
            }
            return pixels;
        }

        function decodeDXT3Block(src, off) {
            const alphas = new Uint8Array(16);
            for (let i = 0; i < 8; i++) {
                alphas[i * 2] = (src[off + i] & 0x0F) * 17;
                alphas[i * 2 + 1] = ((src[off + i] >> 4) & 0x0F) * 17;
            }
            const px = decodeDXT1Block(src, off + 8);
            for (let i = 0; i < 16; i++) px[i * 4 + 3] = alphas[i];
            return px;
        }

        function decodeDXT5Block(src, off) {
            const a0 = src[off], a1 = src[off + 1];
            const ab0 = src[off + 2] | (src[off + 3] << 8) | (src[off + 4] << 16);
            const ab1 = src[off + 5] | (src[off + 6] << 8) | (src[off + 7] << 16);
            const ai = [];
            for (let i = 0; i < 8; i++) ai.push((ab0 >> (i * 3)) & 0x7);
            for (let i = 0; i < 8; i++) ai.push((ab1 >> (i * 3)) & 0x7);

            const ap = new Uint8Array(8);
            ap[0] = a0; ap[1] = a1;
            if (a0 > a1) {
                for (let i = 2; i < 8; i++) ap[i] = ((8 - i) * a0 + (i - 1) * a1 + 3) / 7 | 0;
            } else {
                for (let i = 2; i < 6; i++) ap[i] = ((6 - i) * a0 + (i - 1) * a1 + 2) / 5 | 0;
                ap[6] = 0; ap[7] = 255;
            }

            const px = decodeDXT1Block(src, off + 8);
            for (let i = 0; i < 16; i++) px[i * 4 + 3] = ap[ai[i]];
            return px;
        }

        function decompressDXT(mip, fmt) {
            const { width, height, data } = mip;
            const out = new Uint8Array(width * height * 4);
            const bx = Math.max(1, Math.ceil(width / 4));
            const by = Math.max(1, Math.ceil(height / 4));
            const bs = fmt === 'DXT1' ? 8 : 16;

            for (let y = 0; y < by; y++) {
                for (let x = 0; x < bx; x++) {
                    const bo = (y * bx + x) * bs;
                    let px;
                    if (fmt === 'DXT1') px = decodeDXT1Block(data, bo);
                    else if (fmt === 'DXT3') px = decodeDXT3Block(data, bo);
                    else px = decodeDXT5Block(data, bo);

                    for (let py = 0; py < 4; py++) {
                        for (let ppx = 0; ppx < 4; ppx++) {
                            const dx = x * 4 + ppx, dy = y * 4 + py;
                            if (dx >= width || dy >= height) continue;
                            const si = (py * 4 + ppx) * 4, di = (dy * width + dx) * 4;
                            out[di] = px[si]; out[di + 1] = px[si + 1]; out[di + 2] = px[si + 2]; out[di + 3] = px[si + 3];
                        }
                    }
                }
            }
            return out;
        }

        function decodeUncompressed(mip, dds) {
            const { width, height, data } = mip;
            const out = new Uint8Array(width * height * 4);
            if (dds.format === 'BGRA8') {
                for (let i = 0; i < width * height; i++) {
                    out[i * 4] = data[i * 4 + 2]; out[i * 4 + 1] = data[i * 4 + 1]; out[i * 4 + 2] = data[i * 4]; out[i * 4 + 3] = data[i * 4 + 3];
                }
            } else if (dds.format === 'RGBA8' || dds.format === 'RGBA32_CUSTOM') {
                out.set(data);
            } else if (dds.format === 'RGB24') {
                for (let i = 0; i < width * height; i++) {
                    out[i * 4] = data[i * 3]; out[i * 4 + 1] = data[i * 3 + 1]; out[i * 4 + 2] = data[i * 3 + 2]; out[i * 4 + 3] = 255;
                }
            }
            return out;
        }

        function decodeToRGBA(mip, dds) {
            if (dds.format === 'DXT1' || dds.format === 'DXT3' || dds.format === 'DXT5') {
                return decompressDXT(mip, dds.format);
            }
            return decodeUncompressed(mip, dds);
        }

        // ========================================================
        // Channel Filtering
        // ========================================================
        function applyChannel(rgba, ch, w, h) {
            if (ch === 'rgba') return rgba;
            const out = new Uint8Array(rgba.length);
            for (let i = 0; i < w * h; i++) {
                const o = i * 4;
                const r = rgba[o], g = rgba[o + 1], b = rgba[o + 2], a = rgba[o + 3];
                if (ch === 'r') { out[o] = r; out[o + 1] = 0; out[o + 2] = 0; out[o + 3] = 255; }
                else if (ch === 'g') { out[o] = 0; out[o + 1] = g; out[o + 2] = 0; out[o + 3] = 255; }
                else if (ch === 'b') { out[o] = 0; out[o + 1] = 0; out[o + 2] = b; out[o + 3] = 255; }
                else if (ch === 'a') { out[o] = a; out[o + 1] = a; out[o + 2] = a; out[o + 3] = 255; }
            }
            return out;
        }

        // ========================================================
        // App State & UI
        // ========================================================
        let currentDDS = null;
        let currentRGBA = null;
        let currentChannel = 'rgba';
        let currentMip = 0;
        let showChecker = true;
        let zoom = 1;
        let panX = 0, panY = 0;
        let isPanning = false;
        let panStartX = 0, panStartY = 0;
        let panStartPanX = 0, panStartPanY = 0;
        let fileName = '';
        let isAnimated = false;
        let animatedImgUrl = null;

        const canvas = document.getElementById('dds-canvas');
        const ctx = canvas.getContext('2d');
        const canvasArea = document.getElementById('canvas-area');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const mipSelect = document.getElementById('mip-select');

        const gifImg = document.getElementById('gif-img');

        function renderCanvas() {
            if (!currentDDS) return;
            const mip = currentDDS.mipmaps[currentMip];
            const w = mip.width, h = mip.height;

            canvasWrapper.style.width = w + 'px';
            canvasWrapper.style.height = h + 'px';

            // Animated GIF in RGBA mode: show <img>, hide canvas
            if (isAnimated && currentChannel === 'rgba') {
                canvas.style.display = 'none';
                gifImg.style.display = 'block';
                gifImg.style.width = w + 'px';
                gifImg.style.height = h + 'px';
            } else {
                // For channel views on GIF, capture current frame
                if (isAnimated && currentChannel !== 'rgba') {
                    const tmpCanvas = document.createElement('canvas');
                    tmpCanvas.width = w;
                    tmpCanvas.height = h;
                    const tmpCtx = tmpCanvas.getContext('2d');
                    tmpCtx.drawImage(gifImg, 0, 0, w, h);
                    const imgData = tmpCtx.getImageData(0, 0, w, h);
                    currentRGBA = new Uint8Array(imgData.data.buffer);
                }

                gifImg.style.display = 'none';
                canvas.style.display = 'block';
                canvas.width = w;
                canvas.height = h;

                if (!currentRGBA) return;
                const filtered = applyChannel(currentRGBA, currentChannel, w, h);
                const imgData = new ImageData(new Uint8ClampedArray(filtered), w, h);
                ctx.clearRect(0, 0, w, h);
                ctx.putImageData(imgData, 0, 0);
            }

            if (showChecker && currentChannel === 'rgba') {
                canvasWrapper.classList.add('checker-bg');
            } else {
                canvasWrapper.classList.remove('checker-bg');
            }
            updateTransform();
        }

        function updateTransform() {
            canvasWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
        }

        function updateInfo() {
            if (!currentDDS) return;
            const mip = currentDDS.mipmaps[currentMip];
            document.getElementById('info-size').textContent = mip.width + ' \u00d7 ' + mip.height;
            document.getElementById('info-format').textContent = currentDDS.format;
            document.getElementById('info-mips').textContent = currentDDS.mipMapCount;
            document.getElementById('info-name').textContent = fileName || '\u2014';
            document.getElementById('zoom-label').textContent = Math.round(zoom * 100) + '%';
        }

        // ========================================================
        // File Loading (DDS vs Standard Image)
        // ========================================================
        const DDS_EXTENSIONS = ['.dds'];
        const IMG_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp', '.tga', '.tiff', '.tif', '.svg', '.ico', '.avif'];

        function getExtension(name) {
            const dot = name.lastIndexOf('.');
            return dot >= 0 ? name.substring(dot).toLowerCase() : '';
        }

        function loadFile(file) {
            const ext = getExtension(file.name);
            if (DDS_EXTENSIONS.includes(ext)) {
                const reader = new FileReader();
                reader.onload = () => loadDDSBuffer(reader.result, file.name);
                reader.readAsArrayBuffer(file);
            } else {
                loadImageFile(file);
            }
        }

        function loadImageFile(file) {
            const ext = getExtension(file.name);
            const isGif = (ext === '.gif');
            const url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => {
                const w = img.naturalWidth;
                const h = img.naturalHeight;

                // Clean up previous animated URL
                if (animatedImgUrl) { URL.revokeObjectURL(animatedImgUrl); animatedImgUrl = null; }

                if (isGif) {
                    // Keep URL alive for animated playback
                    isAnimated = true;
                    animatedImgUrl = url;
                    gifImg.src = url;

                    // Extract first frame for channel views
                    const tmpCanvas = document.createElement('canvas');
                    tmpCanvas.width = w;
                    tmpCanvas.height = h;
                    const tmpCtx = tmpCanvas.getContext('2d');
                    tmpCtx.drawImage(img, 0, 0);
                    const imgData = tmpCtx.getImageData(0, 0, w, h);
                    currentRGBA = new Uint8Array(imgData.data.buffer);
                } else {
                    isAnimated = false;
                    gifImg.style.display = 'none';
                    gifImg.src = '';
                    URL.revokeObjectURL(url);

                    // Extract RGBA
                    const tmpCanvas = document.createElement('canvas');
                    tmpCanvas.width = w;
                    tmpCanvas.height = h;
                    const tmpCtx = tmpCanvas.getContext('2d');
                    tmpCtx.drawImage(img, 0, 0);
                    const imgData = tmpCtx.getImageData(0, 0, w, h);
                    currentRGBA = new Uint8Array(imgData.data.buffer);
                }

                const fmtLabel = ext.replace('.', '').toUpperCase();
                currentDDS = {
                    width: w, height: h,
                    format: fmtLabel + (isGif ? ' (animated)' : ''),
                    mipMapCount: 1,
                    mipmaps: [{ width: w, height: h, data: currentRGBA, offset: 0, size: currentRGBA.length }],
                };
                fileName = file.name;
                currentMip = 0;

                mipSelect.innerHTML = '<option value="0">Level 0 (' + w + '\u00d7' + h + ')</option>';

                dropZone.classList.add('hidden');
                canvasWrapper.style.display = 'block';

                fitToView();
                renderCanvas();
                updateInfo();
            };
            img.onerror = () => {
                URL.revokeObjectURL(url);
                alert('\uc774\ubbf8\uc9c0 \ud30c\uc77c\uc744 \uc77d\uc744 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4: ' + file.name);
            };
            img.src = url;
        }

        function loadDDSBuffer(buffer, name) {
            try {
                const dds = parseDDS(buffer);
                currentDDS = dds;
                fileName = name || '';
                currentMip = 0;

                mipSelect.innerHTML = '';
                for (let i = 0; i < dds.mipMapCount && i < dds.mipmaps.length; i++) {
                    const opt = document.createElement('option');
                    const m = dds.mipmaps[i];
                    opt.value = i;
                    opt.textContent = `Level ${i} (${m.width}\u00d7${m.height})`;
                    mipSelect.appendChild(opt);
                }

                currentRGBA = decodeToRGBA(dds.mipmaps[0], dds);

                dropZone.classList.add('hidden');
                canvasWrapper.style.display = 'block';

                fitToView();
                renderCanvas();
                updateInfo();
            } catch (e) {
                alert('DDS 파일을 읽는중 오류가 발생했습니다:\n' + e.message);
                console.error(e);
            }
        }

        function fitToView() {
            if (!currentDDS) return;
            const mip = currentDDS.mipmaps[currentMip];
            const areaW = canvasArea.clientWidth;
            const areaH = canvasArea.clientHeight;
            const padding = 40;

            const scaleX = (areaW - padding * 2) / mip.width;
            const scaleY = (areaH - padding * 2) / mip.height;
            zoom = Math.min(scaleX, scaleY, 4);
            zoom = Math.max(zoom, 0.05);

            panX = (areaW - mip.width * zoom) / 2;
            panY = (areaH - mip.height * zoom) / 2;

            updateTransform();
            updateInfo();
        }

        // ========================================================
        // Event Handlers
        // ========================================================

        // File open
        document.getElementById('btn-open').addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            loadFile(file);
            fileInput.value = '';
        });

        // Drag & Drop
        canvasArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            canvasArea.classList.add('drag-over');
        });

        canvasArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            canvasArea.classList.remove('drag-over');
        });

        canvasArea.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            canvasArea.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (!file) return;
            loadFile(file);
        });

        // Click drop zone to open
        dropZone.addEventListener('click', () => fileInput.click());

        // Channel buttons
        document.querySelectorAll('.channel-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.channel-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentChannel = btn.dataset.channel;
                renderCanvas();
            });
        });

        // Checker toggle
        document.getElementById('toggle-checker').addEventListener('click', function () {
            showChecker = !showChecker;
            this.classList.toggle('active', showChecker);
            renderCanvas();
        });

        // Mip select
        mipSelect.addEventListener('change', () => {
            currentMip = parseInt(mipSelect.value);
            currentRGBA = decodeToRGBA(currentDDS.mipmaps[currentMip], currentDDS);
            renderCanvas();
            updateInfo();
        });

        // Zoom
        document.getElementById('zoom-in').addEventListener('click', () => setZoomCenter(zoom * 1.25));
        document.getElementById('zoom-out').addEventListener('click', () => setZoomCenter(zoom / 1.25));
        document.getElementById('zoom-fit').addEventListener('click', fitToView);

        function setZoomCenter(newZoom) {
            newZoom = Math.min(Math.max(newZoom, 0.05), 32);
            const areaW = canvasArea.clientWidth;
            const areaH = canvasArea.clientHeight;
            const cx = areaW / 2, cy = areaH / 2;
            panX = cx - (cx - panX) * (newZoom / zoom);
            panY = cy - (cy - panY) * (newZoom / zoom);
            zoom = newZoom;
            updateTransform();
            updateInfo();
        }

        // Mouse wheel zoom
        canvasArea.addEventListener('wheel', (e) => {
            e.preventDefault();
            const factor = e.deltaY < 0 ? 1.15 : 1 / 1.15;
            const newZoom = Math.min(Math.max(zoom * factor, 0.05), 32);
            const rect = canvasArea.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            panX = mx - (mx - panX) * (newZoom / zoom);
            panY = my - (my - panY) * (newZoom / zoom);
            zoom = newZoom;
            updateTransform();
            updateInfo();
        }, { passive: false });

        // Pan
        canvasArea.addEventListener('mousedown', (e) => {
            if (e.button !== 0 && e.button !== 1) return;
            isPanning = true;
            panStartX = e.clientX;
            panStartY = e.clientY;
            panStartPanX = panX;
            panStartPanY = panY;
        });

        window.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            panX = panStartPanX + (e.clientX - panStartX);
            panY = panStartPanY + (e.clientY - panStartY);
            updateTransform();
        });

        window.addEventListener('mouseup', () => { isPanning = false; });

        // Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            if (e.key === '1') clickChannel('rgba');
            else if (e.key === '2') clickChannel('r');
            else if (e.key === '3') clickChannel('g');
            else if (e.key === '4') clickChannel('b');
            else if (e.key === '5') clickChannel('a');
            else if (e.key === 'f' || e.key === 'F') fitToView();
            else if (e.key === '+' || e.key === '=') setZoomCenter(zoom * 1.25);
            else if (e.key === '-') setZoomCenter(zoom / 1.25);
        });

        function clickChannel(ch) {
            const btn = document.querySelector(`.channel-btn[data-channel="${ch}"]`);
            if (btn) btn.click();
        }
    </script>
</body>

</html>