<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aura Image Viewer</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='16' fill='%236c5ce7'/><text x='50' y='64' text-anchor='middle' font-size='52' font-weight='bold' fill='white' font-family='sans-serif'>A</text></svg>">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0d0d12;
            --bg-secondary: #16161e;
            --bg-tertiary: #1e1e2a;
            --bg-hover: #262636;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
            --text-dim: #55556a;
            --accent: #6c5ce7;
            --accent-light: #a29bfe;
            --accent-glow: rgba(108, 92, 231, 0.3);
            --border: #2a2a3c;
            --red: #ff6b6b;
            --green: #51cf66;
            --blue: #339af0;
            --alpha-checker: #2a2a2a;
            --radius: 12px;
            --radius-sm: 8px;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        /* ===== Header ===== */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
            font-weight: 600;
            letter-spacing: -0.3px;
        }

        .header-title .icon {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: linear-gradient(135deg, var(--accent), #a29bfe);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .btn {
            padding: 7px 16px;
            border-radius: var(--radius-sm);
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent);
            box-shadow: 0 0 12px var(--accent-glow);
        }

        .btn-primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: var(--accent-light);
        }

        /* ===== Toolbar ===== */
        .toolbar {
            display: flex;
            align-items: center;
            padding: 8px 24px;
            gap: 6px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            flex-wrap: wrap;
        }

        .toolbar .separator {
            width: 1px;
            height: 24px;
            background: var(--border);
            margin: 0 8px;
        }

        .channel-btn {
            padding: 5px 12px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-family: inherit;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
            letter-spacing: 0.5px;
        }

        .channel-btn:hover {
            background: var(--bg-hover);
        }

        .channel-btn.active {
            color: #fff;
            border-color: transparent;
        }

        .channel-btn.active[data-channel="rgba"] {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent-glow);
        }

        .channel-btn.active[data-channel="r"] {
            background: var(--red);
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.3);
        }

        .channel-btn.active[data-channel="g"] {
            background: var(--green);
            box-shadow: 0 0 10px rgba(81, 207, 102, 0.3);
        }

        .channel-btn.active[data-channel="b"] {
            background: var(--blue);
            box-shadow: 0 0 10px rgba(51, 154, 240, 0.3);
        }

        .channel-btn.active[data-channel="a"] {
            background: #888;
            box-shadow: 0 0 10px rgba(136, 136, 136, 0.3);
        }

        .info-bar {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-left: auto;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .info-item .label {
            color: var(--text-dim);
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .zoom-btn {
            width: 26px;
            height: 26px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .zoom-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .zoom-label {
            font-size: 12px;
            color: var(--text-secondary);
            min-width: 42px;
            text-align: center;
            font-variant-numeric: tabular-nums;
        }

        /* ===== Main Canvas Area ===== */
        .canvas-area {
            flex: 1;
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        .canvas-area:active {
            cursor: grabbing;
        }

        .canvas-area.drag-over::after {
            content: '';
            position: absolute;
            inset: 0;
            background: rgba(108, 92, 231, 0.08);
            border: 2px dashed var(--accent);
            z-index: 10;
            pointer-events: none;
        }

        .canvas-wrapper {
            position: absolute;
            transform-origin: 0 0;
        }

        .checker-bg {
            background-image:
                linear-gradient(45deg, var(--alpha-checker) 25%, transparent 25%),
                linear-gradient(-45deg, var(--alpha-checker) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, var(--alpha-checker) 75%),
                linear-gradient(-45deg, transparent 75%, var(--alpha-checker) 75%);
            background-size: 16px 16px;
            background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
            background-color: #1a1a1a;
        }

        #dds-canvas {
            display: block;
            image-rendering: pixelated;
        }

        /* ===== Drop Zone ===== */
        .drop-zone {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            z-index: 5;
        }

        .drop-zone.hidden {
            display: none;
        }

        .drop-icon {
            width: 80px;
            height: 80px;
            border-radius: 20px;
            background: var(--bg-tertiary);
            border: 2px dashed var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-dim);
            transition: all 0.3s ease;
        }

        .canvas-area.drag-over .drop-icon {
            border-color: var(--accent);
            color: var(--accent);
            background: rgba(108, 92, 231, 0.1);
            transform: scale(1.05);
        }

        .drop-text {
            font-size: 15px;
            color: var(--text-secondary);
        }

        .drop-subtext {
            font-size: 12px;
            color: var(--text-dim);
        }

        .mip-select {
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-family: inherit;
            font-size: 12px;
            cursor: pointer;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-dim);
        }

        .toggle-wrap {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .toggle {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--border);
            position: relative;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle.active {
            background: var(--accent);
        }

        .toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s;
        }

        .toggle.active::after {
            transform: translateX(14px);
        }

        #video-player {
            display: none;
            max-width: 100%;
            max-height: 100%;
            outline: none;
            border-radius: 4px;
        }

        #gif-img {
            display: none;
            image-rendering: auto;
        }

        /* ===== Navigation Buttons ===== */
        .nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 44px;
            height: 72px;
            border: none;
            border-radius: 8px;
            background: rgba(22, 22, 30, 0.85);
            color: var(--text-secondary);
            font-size: 22px;
            cursor: pointer;
            z-index: 20;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            backdrop-filter: blur(8px);
            border: 1px solid var(--border);
        }

        .nav-btn:hover {
            background: rgba(30, 30, 42, 0.95);
            color: var(--text-primary);
            border-color: var(--accent);
            box-shadow: 0 0 16px var(--accent-glow);
        }

        .nav-btn.show {
            display: flex;
        }

        .nav-prev {
            left: 16px;
        }

        .nav-next {
            right: 16px;
        }

        /* ===== File Counter ===== */
        .file-counter {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 16px;
            border-radius: 20px;
            background: rgba(22, 22, 30, 0.85);
            backdrop-filter: blur(8px);
            border: 1px solid var(--border);
            font-size: 12px;
            color: var(--text-secondary);
            z-index: 20;
            display: none;
            font-variant-numeric: tabular-nums;
        }

        .file-counter.show {
            display: block;
        }
    </style>
</head>

<body>

    <!-- Header -->
    <div class="header">
        <div class="header-title">
            <div class="icon">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                    <circle cx="8.5" cy="8.5" r="1.5" />
                    <polyline points="21 15 16 10 5 21" />
                </svg>
            </div>
            <span>Aura Image Viewer</span>
        </div>
        <div class="header-actions">
            <button class="btn btn-primary" id="btn-open">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                    stroke-linecap="round" stroke-linejoin="round">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />
                </svg>
                파일 열기
            </button>
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar" id="toolbar">
        <button class="channel-btn active" data-channel="rgba">RGBA</button>
        <button class="channel-btn" data-channel="r">R</button>
        <button class="channel-btn" data-channel="g">G</button>
        <button class="channel-btn" data-channel="b">B</button>
        <button class="channel-btn" data-channel="a">A</button>

        <div class="separator"></div>

        <div class="toggle-wrap">
            <div class="toggle active" id="toggle-checker"></div>
            <span>투명 배경</span>
        </div>

        <div class="separator"></div>

        <span style="font-size:12px; color: var(--text-dim);">Mip:</span>
        <select class="mip-select" id="mip-select">
            <option value="0">Level 0</option>
        </select>

        <div class="separator"></div>

        <div class="zoom-controls">
            <button class="zoom-btn" id="zoom-out">&minus;</button>
            <span class="zoom-label" id="zoom-label">100%</span>
            <button class="zoom-btn" id="zoom-in">+</button>
            <button class="zoom-btn" id="zoom-fit" title="화면에 맞추기">&#x229E;</button>
        </div>

        <div class="info-bar" id="info-bar">
            <div class="info-item">
                <span class="label">크기:</span>
                <span id="info-size">&mdash;</span>
            </div>
            <div class="info-item">
                <span class="label">포맷:</span>
                <span id="info-format">&mdash;</span>
            </div>
            <div class="info-item">
                <span class="label">Mips:</span>
                <span id="info-mips">&mdash;</span>
            </div>
            <div class="info-item">
                <span class="label">파일:</span>
                <span id="info-name">&mdash;</span>
            </div>
        </div>
    </div>

    <!-- Canvas Area -->
    <div class="canvas-area" id="canvas-area">
        <div class="drop-zone" id="drop-zone">
            <div class="drop-icon">
                <svg width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"
                    stroke-linecap="round" stroke-linejoin="round">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                    <circle cx="8.5" cy="8.5" r="1.5" />
                    <polyline points="21 15 16 10 5 21" />
                </svg>
            </div>
            <div class="drop-text">파일을 드래그하거나 클릭하여 열기</div>
            <div class="drop-subtext">DDS &middot; PNG &middot; JPG &middot; GIF &middot; BMP &middot; WebP &middot; MP4
                &middot; WebM</div>
            <div class="drop-subtext" style="margin-top: -8px;">여러 파일 선택 또는 폴더 드롭 시 좌우 탐색 가능</div>
        </div>
        <div class="canvas-wrapper checker-bg" id="canvas-wrapper" style="display:none;">
            <canvas id="dds-canvas"></canvas>
            <img id="gif-img">
            <video id="video-player" loop controls></video>
        </div>

        <!-- Navigation -->
        <button class="nav-btn nav-prev" id="nav-prev">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                stroke-linecap="round" stroke-linejoin="round">
                <polyline points="15 18 9 12 15 6" />
            </svg>
        </button>
        <button class="nav-btn nav-next" id="nav-next">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"
                stroke-linecap="round" stroke-linejoin="round">
                <polyline points="9 6 15 12 9 18" />
            </svg>
        </button>
        <div class="file-counter" id="file-counter"></div>
    </div>

    <input type="file" id="file-input"
        accept=".dds,.png,.jpg,.jpeg,.gif,.bmp,.webp,.tga,.tiff,.tif,.svg,.mp4,.webm,.mov,.avi,.mkv,.ogg" multiple
        style="display:none;">

    <script>
        // ========================================================
        // DDS Parser
        // ========================================================
        const DDS_MAGIC = 0x20534444;
        const DDPF_FOURCC = 0x4;
        const DDPF_RGB = 0x40;
        const FOURCC_DXT1 = 0x31545844;
        const FOURCC_DXT3 = 0x33545844;
        const FOURCC_DXT5 = 0x35545844;

        function parseDDS(buffer) {
            const view = new DataView(buffer);
            if (view.getUint32(0, true) !== DDS_MAGIC) throw new Error('유효하지 않은 DDS 파일입니다.');
            if (view.getUint32(4, true) !== 124) throw new Error('DDS 헤더 크기가 올바르지 않습니다.');

            const height = view.getUint32(12, true);
            const width = view.getUint32(16, true);
            const mipMapCount = Math.max(1, view.getUint32(28, true));
            const pfFlags = view.getUint32(80, true);
            const fourCC = view.getUint32(84, true);
            const rgbBitCount = view.getUint32(88, true);
            const rMask = view.getUint32(92, true);
            const gMask = view.getUint32(96, true);
            const bMask = view.getUint32(100, true);
            const aMask = view.getUint32(104, true);

            let format = 'unknown';
            if (pfFlags & DDPF_FOURCC) {
                if (fourCC === FOURCC_DXT1) format = 'DXT1';
                else if (fourCC === FOURCC_DXT3) format = 'DXT3';
                else if (fourCC === FOURCC_DXT5) format = 'DXT5';
                else format = 'FOURCC_0x' + fourCC.toString(16);
            } else if (pfFlags & DDPF_RGB) {
                if (rgbBitCount === 32) {
                    if (rMask === 0xFF && bMask === 0xFF0000) format = 'RGBA8';
                    else if (rMask === 0xFF0000 && bMask === 0xFF) format = 'BGRA8';
                    else format = 'RGBA32_CUSTOM';
                } else if (rgbBitCount === 24) format = 'RGB24';
                else format = 'RGB_' + rgbBitCount + 'bit';
            }

            const mipmaps = [];
            let offset = 128;
            for (let i = 0; i < mipMapCount; i++) {
                const mW = Math.max(1, width >> i), mH = Math.max(1, height >> i);
                let sz;
                if (format === 'DXT1') sz = Math.max(1, Math.ceil(mW / 4)) * Math.max(1, Math.ceil(mH / 4)) * 8;
                else if (format === 'DXT3' || format === 'DXT5') sz = Math.max(1, Math.ceil(mW / 4)) * Math.max(1, Math.ceil(mH / 4)) * 16;
                else if (format === 'RGBA8' || format === 'BGRA8' || format === 'RGBA32_CUSTOM') sz = mW * mH * 4;
                else if (format === 'RGB24') sz = mW * mH * 3;
                else sz = mW * mH * Math.max(1, rgbBitCount / 8);
                if (offset + sz > buffer.byteLength) break;
                mipmaps.push({ width: mW, height: mH, data: new Uint8Array(buffer, offset, sz), offset, size: sz });
                offset += sz;
            }
            return { width, height, format, mipMapCount, mipmaps, pfFlags, rgbBitCount, rMask, gMask, bMask, aMask };
        }

        // ========================================================
        // DXT Decompression
        // ========================================================
        function unpack565(c) {
            return [((c >> 11) & 0x1F) * 255 / 31 | 0, ((c >> 5) & 0x3F) * 255 / 63 | 0, (c & 0x1F) * 255 / 31 | 0, 255];
        }

        function dxt1Block(s, o) {
            const c0 = s[o] | (s[o + 1] << 8), c1 = s[o + 2] | (s[o + 3] << 8);
            const a = unpack565(c0), b = unpack565(c1);
            const cl = [a, b, [0, 0, 0, 255], [0, 0, 0, 255]];
            if (c0 > c1) {
                cl[2] = [(2 * a[0] + b[0] + 1) / 3 | 0, (2 * a[1] + b[1] + 1) / 3 | 0, (2 * a[2] + b[2] + 1) / 3 | 0, 255];
                cl[3] = [(a[0] + 2 * b[0] + 1) / 3 | 0, (a[1] + 2 * b[1] + 1) / 3 | 0, (a[2] + 2 * b[2] + 1) / 3 | 0, 255];
            } else {
                cl[2] = [(a[0] + b[0]) / 2 | 0, (a[1] + b[1]) / 2 | 0, (a[2] + b[2]) / 2 | 0, 255];
                cl[3] = [0, 0, 0, 0];
            }
            const px = new Uint8Array(64);
            const bits = s[o + 4] | (s[o + 5] << 8) | (s[o + 6] << 16) | (s[o + 7] << 24);
            for (let i = 0; i < 16; i++) { const idx = (bits >> (i * 2)) & 3, c = cl[idx]; px[i * 4] = c[0]; px[i * 4 + 1] = c[1]; px[i * 4 + 2] = c[2]; px[i * 4 + 3] = c[3]; }
            return px;
        }

        function dxt3Block(s, o) {
            const al = new Uint8Array(16);
            for (let i = 0; i < 8; i++) { al[i * 2] = (s[o + i] & 0xF) * 17; al[i * 2 + 1] = ((s[o + i] >> 4) & 0xF) * 17; }
            const px = dxt1Block(s, o + 8);
            for (let i = 0; i < 16; i++) px[i * 4 + 3] = al[i];
            return px;
        }

        function dxt5Block(s, o) {
            const a0 = s[o], a1 = s[o + 1];
            const ab0 = s[o + 2] | (s[o + 3] << 8) | (s[o + 4] << 16), ab1 = s[o + 5] | (s[o + 6] << 8) | (s[o + 7] << 16);
            const ai = [];
            for (let i = 0; i < 8; i++) ai.push((ab0 >> (i * 3)) & 7);
            for (let i = 0; i < 8; i++) ai.push((ab1 >> (i * 3)) & 7);
            const ap = new Uint8Array(8); ap[0] = a0; ap[1] = a1;
            if (a0 > a1) { for (let i = 2; i < 8; i++) ap[i] = ((8 - i) * a0 + (i - 1) * a1 + 3) / 7 | 0; }
            else { for (let i = 2; i < 6; i++) ap[i] = ((6 - i) * a0 + (i - 1) * a1 + 2) / 5 | 0; ap[6] = 0; ap[7] = 255; }
            const px = dxt1Block(s, o + 8);
            for (let i = 0; i < 16; i++) px[i * 4 + 3] = ap[ai[i]];
            return px;
        }

        function decompressDXT(mip, fmt) {
            const { width: w, height: h, data } = mip;
            const out = new Uint8Array(w * h * 4);
            const bx = Math.max(1, Math.ceil(w / 4)), by = Math.max(1, Math.ceil(h / 4));
            const bs = fmt === 'DXT1' ? 8 : 16;
            for (let y = 0; y < by; y++) for (let x = 0; x < bx; x++) {
                const bo = (y * bx + x) * bs;
                let px;
                if (fmt === 'DXT1') px = dxt1Block(data, bo);
                else if (fmt === 'DXT3') px = dxt3Block(data, bo);
                else px = dxt5Block(data, bo);
                for (let py = 0; py < 4; py++) for (let ppx = 0; ppx < 4; ppx++) {
                    const dx = x * 4 + ppx, dy = y * 4 + py;
                    if (dx >= w || dy >= h) continue;
                    const si = (py * 4 + ppx) * 4, di = (dy * w + dx) * 4;
                    out[di] = px[si]; out[di + 1] = px[si + 1]; out[di + 2] = px[si + 2]; out[di + 3] = px[si + 3];
                }
            }
            return out;
        }

        function decodeUncompressed(mip, dds) {
            const { width: w, height: h, data } = mip; const out = new Uint8Array(w * h * 4);
            if (dds.format === 'BGRA8') { for (let i = 0; i < w * h; i++) { out[i * 4] = data[i * 4 + 2]; out[i * 4 + 1] = data[i * 4 + 1]; out[i * 4 + 2] = data[i * 4]; out[i * 4 + 3] = data[i * 4 + 3]; } }
            else if (dds.format === 'RGBA8' || dds.format === 'RGBA32_CUSTOM') { out.set(data); }
            else if (dds.format === 'RGB24') { for (let i = 0; i < w * h; i++) { out[i * 4] = data[i * 3]; out[i * 4 + 1] = data[i * 3 + 1]; out[i * 4 + 2] = data[i * 3 + 2]; out[i * 4 + 3] = 255; } }
            return out;
        }

        function decodeToRGBA(mip, dds) {
            return (dds.format === 'DXT1' || dds.format === 'DXT3' || dds.format === 'DXT5') ? decompressDXT(mip, dds.format) : decodeUncompressed(mip, dds);
        }

        // ========================================================
        // Channel Filtering
        // ========================================================
        function applyChannel(rgba, ch, w, h) {
            if (ch === 'rgba') return rgba;
            const out = new Uint8Array(rgba.length);
            for (let i = 0; i < w * h; i++) {
                const o = i * 4, r = rgba[o], g = rgba[o + 1], b = rgba[o + 2], a = rgba[o + 3];
                if (ch === 'r') { out[o] = r; out[o + 1] = 0; out[o + 2] = 0; out[o + 3] = 255; }
                else if (ch === 'g') { out[o] = 0; out[o + 1] = g; out[o + 2] = 0; out[o + 3] = 255; }
                else if (ch === 'b') { out[o] = 0; out[o + 1] = 0; out[o + 2] = b; out[o + 3] = 255; }
                else if (ch === 'a') { out[o] = a; out[o + 1] = a; out[o + 2] = a; out[o + 3] = 255; }
            }
            return out;
        }

        // ========================================================
        // App State
        // ========================================================
        let currentDDS = null;
        let currentRGBA = null;
        let currentChannel = 'rgba';
        let currentMip = 0;
        let showChecker = true;
        let zoom = 1;
        let panX = 0, panY = 0;
        let isPanning = false;
        let panStartX = 0, panStartY = 0;
        let panStartPanX = 0, panStartPanY = 0;
        let fileName = '';
        let isAnimated = false;
        let isVideo = false;
        let mediaUrl = null;

        // File list navigation
        let fileList = [];
        let fileIndex = -1;

        const canvas = document.getElementById('dds-canvas');
        const ctx = canvas.getContext('2d');
        const canvasArea = document.getElementById('canvas-area');
        const canvasWrapper = document.getElementById('canvas-wrapper');
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('file-input');
        const mipSelect = document.getElementById('mip-select');
        const gifImg = document.getElementById('gif-img');
        const videoPlayer = document.getElementById('video-player');
        const navPrev = document.getElementById('nav-prev');
        const navNext = document.getElementById('nav-next');
        const fileCounter = document.getElementById('file-counter');

        const SUPPORTED_EXT = ['.dds', '.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp', '.tga', '.tiff', '.tif', '.svg', '.ico', '.avif', '.mp4', '.webm', '.mov', '.avi', '.mkv', '.ogg'];
        const DDS_EXT = ['.dds'];
        const VIDEO_EXT = ['.mp4', '.webm', '.mov', '.avi', '.mkv', '.ogg'];

        function getExt(name) {
            const d = name.lastIndexOf('.');
            return d >= 0 ? name.substring(d).toLowerCase() : '';
        }

        // ========================================================
        // Render
        // ========================================================
        function renderCanvas() {
            if (!currentDDS) return;
            const mip = currentDDS.mipmaps[currentMip];
            const w = mip.width, h = mip.height;

            canvasWrapper.style.width = w + 'px';
            canvasWrapper.style.height = h + 'px';

            if (isVideo) {
                canvas.style.display = 'none';
                gifImg.style.display = 'none';
                if (currentChannel === 'rgba') {
                    videoPlayer.style.display = 'block';
                    videoPlayer.style.width = w + 'px';
                    videoPlayer.style.height = h + 'px';
                } else {
                    videoPlayer.style.display = 'none';
                    canvas.style.display = 'block';
                    canvas.width = w; canvas.height = h;
                    ctx.drawImage(videoPlayer, 0, 0, w, h);
                    const imgData = ctx.getImageData(0, 0, w, h);
                    const frameRGBA = new Uint8Array(imgData.data.buffer);
                    const filtered = applyChannel(frameRGBA, currentChannel, w, h);
                    ctx.putImageData(new ImageData(new Uint8ClampedArray(filtered), w, h), 0, 0);
                }
            } else if (isAnimated) {
                videoPlayer.style.display = 'none';
                if (currentChannel === 'rgba') {
                    canvas.style.display = 'none';
                    gifImg.style.display = 'block';
                    gifImg.style.width = w + 'px';
                    gifImg.style.height = h + 'px';
                } else {
                    gifImg.style.display = 'none';
                    canvas.style.display = 'block';
                    canvas.width = w; canvas.height = h;
                    const tmp = document.createElement('canvas');
                    tmp.width = w; tmp.height = h;
                    const tc = tmp.getContext('2d');
                    tc.drawImage(gifImg, 0, 0, w, h);
                    currentRGBA = new Uint8Array(tc.getImageData(0, 0, w, h).data.buffer);
                    const filtered = applyChannel(currentRGBA, currentChannel, w, h);
                    ctx.putImageData(new ImageData(new Uint8ClampedArray(filtered), w, h), 0, 0);
                }
            } else {
                videoPlayer.style.display = 'none';
                gifImg.style.display = 'none';
                canvas.style.display = 'block';
                canvas.width = w; canvas.height = h;
                if (!currentRGBA) return;
                const filtered = applyChannel(currentRGBA, currentChannel, w, h);
                ctx.putImageData(new ImageData(new Uint8ClampedArray(filtered), w, h), 0, 0);
            }

            if (showChecker && currentChannel === 'rgba') {
                canvasWrapper.classList.add('checker-bg');
            } else {
                canvasWrapper.classList.remove('checker-bg');
            }
            updateTransform();
        }

        function updateTransform() {
            canvasWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
        }

        function updateInfo() {
            if (!currentDDS) return;
            const mip = currentDDS.mipmaps[currentMip];
            document.getElementById('info-size').textContent = mip.width + ' \u00d7 ' + mip.height;
            document.getElementById('info-format').textContent = currentDDS.format;
            document.getElementById('info-mips').textContent = currentDDS.mipMapCount;
            document.getElementById('info-name').textContent = fileName || '\u2014';
            document.getElementById('zoom-label').textContent = Math.round(zoom * 100) + '%';
        }

        function updateNav() {
            const multi = fileList.length > 1;
            navPrev.classList.toggle('show', multi);
            navNext.classList.toggle('show', multi);
            fileCounter.classList.toggle('show', multi);
            if (multi) {
                fileCounter.textContent = (fileIndex + 1) + ' / ' + fileList.length;
            }
        }

        // ========================================================
        // File Loading
        // ========================================================
        function cleanupMedia() {
            if (mediaUrl) { URL.revokeObjectURL(mediaUrl); mediaUrl = null; }
            isAnimated = false;
            isVideo = false;
            videoPlayer.pause();
            videoPlayer.src = '';
            videoPlayer.style.display = 'none';
            gifImg.src = '';
            gifImg.style.display = 'none';
        }

        function loadFileFromList(index) {
            if (index < 0 || index >= fileList.length) return;
            fileIndex = index;
            const file = fileList[fileIndex];
            const ext = getExt(file.name);
            cleanupMedia();

            if (DDS_EXT.includes(ext)) {
                const reader = new FileReader();
                reader.onload = () => loadDDSBuffer(reader.result, file.name);
                reader.readAsArrayBuffer(file);
            } else if (VIDEO_EXT.includes(ext)) {
                loadVideoFile(file);
            } else {
                loadImageFile(file);
            }
        }

        function setFileList(files) {
            // Filter to supported formats and sort by name
            fileList = Array.from(files)
                .filter(f => SUPPORTED_EXT.includes(getExt(f.name)))
                .sort((a, b) => a.name.localeCompare(b.name, undefined, { numeric: true }));

            if (fileList.length === 0) return;
            fileIndex = 0;
            loadFileFromList(0);
        }

        function navigatePrev() {
            if (fileList.length <= 1) return;
            const idx = (fileIndex - 1 + fileList.length) % fileList.length;
            loadFileFromList(idx);
        }

        function navigateNext() {
            if (fileList.length <= 1) return;
            const idx = (fileIndex + 1) % fileList.length;
            loadFileFromList(idx);
        }

        function loadImageFile(file) {
            const ext = getExt(file.name);
            const isGif = (ext === '.gif');
            const url = URL.createObjectURL(file);
            const img = new Image();
            img.onload = () => {
                const w = img.naturalWidth, h = img.naturalHeight;
                if (isGif) { isAnimated = true; mediaUrl = url; gifImg.src = url; }
                else { URL.revokeObjectURL(url); }

                const tmp = document.createElement('canvas');
                tmp.width = w; tmp.height = h;
                const tc = tmp.getContext('2d');
                tc.drawImage(img, 0, 0);
                currentRGBA = new Uint8Array(tc.getImageData(0, 0, w, h).data.buffer);

                const fmtLabel = ext.replace('.', '').toUpperCase() + (isGif ? ' (animated)' : '');
                currentDDS = {
                    width: w, height: h, format: fmtLabel, mipMapCount: 1,
                    mipmaps: [{ width: w, height: h, data: currentRGBA, offset: 0, size: currentRGBA.length }],
                };
                fileName = file.name;
                currentMip = 0;
                mipSelect.innerHTML = '<option value="0">Level 0 (' + w + '\u00d7' + h + ')</option>';
                showMedia();
            };
            img.onerror = () => { URL.revokeObjectURL(url); alert('\uc774\ubbf8\uc9c0\ub97c \uc77d\uc744 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4: ' + file.name); };
            img.src = url;
        }

        function loadVideoFile(file) {
            const url = URL.createObjectURL(file);
            mediaUrl = url;
            isVideo = true;
            videoPlayer.src = url;
            videoPlayer.onloadedmetadata = () => {
                const w = videoPlayer.videoWidth, h = videoPlayer.videoHeight;
                const ext = getExt(file.name).replace('.', '').toUpperCase();
                videoPlayer.currentTime = 0;
                videoPlayer.onseeked = () => {
                    const tmp = document.createElement('canvas');
                    tmp.width = w; tmp.height = h;
                    const tc = tmp.getContext('2d');
                    tc.drawImage(videoPlayer, 0, 0);
                    currentRGBA = new Uint8Array(tc.getImageData(0, 0, w, h).data.buffer);
                    currentDDS = {
                        width: w, height: h, format: ext + ' (video)', mipMapCount: 1,
                        mipmaps: [{ width: w, height: h, data: currentRGBA, offset: 0, size: currentRGBA.length }],
                    };
                    fileName = file.name;
                    currentMip = 0;
                    mipSelect.innerHTML = '<option value="0">' + w + '\u00d7' + h + '</option>';
                    showMedia();
                    videoPlayer.play();
                    videoPlayer.onseeked = null;
                };
            };
            videoPlayer.onerror = () => { URL.revokeObjectURL(url); alert('\ube44\ub514\uc624\ub97c \uc77d\uc744 \uc218 \uc5c6\uc2b5\ub2c8\ub2e4: ' + file.name); };
        }

        function loadDDSBuffer(buffer, name) {
            try {
                const dds = parseDDS(buffer);
                currentDDS = dds;
                fileName = name || '';
                currentMip = 0;
                mipSelect.innerHTML = '';
                for (let i = 0; i < dds.mipMapCount && i < dds.mipmaps.length; i++) {
                    const opt = document.createElement('option');
                    const m = dds.mipmaps[i];
                    opt.value = i;
                    opt.textContent = `Level ${i} (${m.width}\u00d7${m.height})`;
                    mipSelect.appendChild(opt);
                }
                currentRGBA = decodeToRGBA(dds.mipmaps[0], dds);
                showMedia();
            } catch (e) {
                alert('DDS \ud30c\uc77c\uc744 \uc77d\ub294\uc911 \uc624\ub958\uac00 \ubc1c\uc0dd\ud588\uc2b5\ub2c8\ub2e4:\n' + e.message);
                console.error(e);
            }
        }

        function showMedia() {
            dropZone.classList.add('hidden');
            canvasWrapper.style.display = 'block';
            fitToView();
            renderCanvas();
            updateInfo();
            updateNav();
        }

        function fitToView() {
            if (!currentDDS) return;
            const mip = currentDDS.mipmaps[currentMip];
            const aW = canvasArea.clientWidth, aH = canvasArea.clientHeight;
            const pad = 40;
            zoom = Math.min((aW - pad * 2) / mip.width, (aH - pad * 2) / mip.height, 4);
            zoom = Math.max(zoom, 0.05);
            panX = (aW - mip.width * zoom) / 2;
            panY = (aH - mip.height * zoom) / 2;
            updateTransform();
            updateInfo();
        }

        // ========================================================
        // Drag & Drop - supports folders via webkitGetAsEntry
        // ========================================================
        async function getFilesFromDrop(dataTransfer) {
            const items = dataTransfer.items;
            const files = [];

            if (items && items.length > 0 && items[0].webkitGetAsEntry) {
                // Use webkitGetAsEntry to handle folder drops
                const entries = [];
                for (let i = 0; i < items.length; i++) {
                    const entry = items[i].webkitGetAsEntry();
                    if (entry) entries.push(entry);
                }

                async function readEntry(entry) {
                    if (entry.isFile) {
                        return new Promise(resolve => {
                            entry.file(f => { files.push(f); resolve(); }, () => resolve());
                        });
                    } else if (entry.isDirectory) {
                        const reader = entry.createReader();
                        const subEntries = await new Promise(resolve => {
                            const results = [];
                            function readBatch() {
                                reader.readEntries(batch => {
                                    if (batch.length === 0) { resolve(results); return; }
                                    results.push(...batch);
                                    readBatch();
                                }, () => resolve(results));
                            }
                            readBatch();
                        });
                        for (const sub of subEntries) {
                            await readEntry(sub);
                        }
                    }
                }

                for (const entry of entries) {
                    await readEntry(entry);
                }
            } else {
                // Fallback: use dataTransfer.files
                for (let i = 0; i < dataTransfer.files.length; i++) {
                    files.push(dataTransfer.files[i]);
                }
            }

            return files;
        }

        // ========================================================
        // Events
        // ========================================================
        document.getElementById('btn-open').addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            const files = e.target.files;
            if (!files || files.length === 0) return;
            setFileList(files);
            fileInput.value = '';
        });

        canvasArea.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); canvasArea.classList.add('drag-over'); });
        canvasArea.addEventListener('dragleave', (e) => { e.preventDefault(); canvasArea.classList.remove('drag-over'); });

        canvasArea.addEventListener('drop', async (e) => {
            e.preventDefault(); e.stopPropagation();
            canvasArea.classList.remove('drag-over');
            const files = await getFilesFromDrop(e.dataTransfer);
            if (files.length === 0) return;
            setFileList(files);
        });

        dropZone.addEventListener('click', () => fileInput.click());

        // Navigation buttons
        navPrev.addEventListener('click', (e) => { e.stopPropagation(); navigatePrev(); });
        navNext.addEventListener('click', (e) => { e.stopPropagation(); navigateNext(); });

        // Channel buttons
        document.querySelectorAll('.channel-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.channel-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentChannel = btn.dataset.channel;
                renderCanvas();
            });
        });

        document.getElementById('toggle-checker').addEventListener('click', function () {
            showChecker = !showChecker;
            this.classList.toggle('active', showChecker);
            renderCanvas();
        });

        mipSelect.addEventListener('change', () => {
            currentMip = parseInt(mipSelect.value);
            if (currentDDS && currentDDS.mipmaps[currentMip] && !isVideo && !isAnimated) {
                currentRGBA = decodeToRGBA(currentDDS.mipmaps[currentMip], currentDDS);
            }
            renderCanvas();
            updateInfo();
        });

        document.getElementById('zoom-in').addEventListener('click', () => setZoomCenter(zoom * 1.25));
        document.getElementById('zoom-out').addEventListener('click', () => setZoomCenter(zoom / 1.25));
        document.getElementById('zoom-fit').addEventListener('click', fitToView);

        function setZoomCenter(nz) {
            nz = Math.min(Math.max(nz, 0.05), 32);
            const cw = canvasArea.clientWidth, ch = canvasArea.clientHeight;
            const cx = cw / 2, cy = ch / 2;
            panX = cx - (cx - panX) * (nz / zoom);
            panY = cy - (cy - panY) * (nz / zoom);
            zoom = nz;
            updateTransform();
            updateInfo();
        }

        // Mouse wheel: Ctrl = zoom, otherwise = navigate
        canvasArea.addEventListener('wheel', (e) => {
            e.preventDefault();

            if (e.ctrlKey || e.metaKey) {
                // Ctrl+Scroll = Zoom
                const f = e.deltaY < 0 ? 1.15 : 1 / 1.15;
                const nz = Math.min(Math.max(zoom * f, 0.05), 32);
                const r = canvasArea.getBoundingClientRect();
                const mx = e.clientX - r.left, my = e.clientY - r.top;
                panX = mx - (mx - panX) * (nz / zoom);
                panY = my - (my - panY) * (nz / zoom);
                zoom = nz;
                updateTransform();
                updateInfo();
            } else {
                // Scroll = Navigate files
                if (fileList.length > 1) {
                    if (e.deltaY > 0) navigateNext();
                    else navigatePrev();
                } else {
                    // Single file: zoom as fallback
                    const f = e.deltaY < 0 ? 1.15 : 1 / 1.15;
                    const nz = Math.min(Math.max(zoom * f, 0.05), 32);
                    const r = canvasArea.getBoundingClientRect();
                    const mx = e.clientX - r.left, my = e.clientY - r.top;
                    panX = mx - (mx - panX) * (nz / zoom);
                    panY = my - (my - panY) * (nz / zoom);
                    zoom = nz;
                    updateTransform();
                    updateInfo();
                }
            }
        }, { passive: false });

        // Pan
        canvasArea.addEventListener('mousedown', (e) => {
            if (e.button !== 0 && e.button !== 1) return;
            // Don't pan on nav buttons
            if (e.target.closest('.nav-btn')) return;
            isPanning = true;
            panStartX = e.clientX; panStartY = e.clientY;
            panStartPanX = panX; panStartPanY = panY;
        });

        window.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            panX = panStartPanX + (e.clientX - panStartX);
            panY = panStartPanY + (e.clientY - panStartY);
            updateTransform();
        });

        window.addEventListener('mouseup', () => { isPanning = false; });

        // Keyboard
        window.addEventListener('keydown', (e) => {
            if (e.key === '1') clickCh('rgba');
            else if (e.key === '2') clickCh('r');
            else if (e.key === '3') clickCh('g');
            else if (e.key === '4') clickCh('b');
            else if (e.key === '5') clickCh('a');
            else if (e.key === 'f' || e.key === 'F') fitToView();
            else if (e.key === '+' || e.key === '=') setZoomCenter(zoom * 1.25);
            else if (e.key === '-') setZoomCenter(zoom / 1.25);
            else if (e.key === 'ArrowLeft') navigatePrev();
            else if (e.key === 'ArrowRight') navigateNext();
            else if (e.key === ' ' && isVideo) { e.preventDefault(); videoPlayer.paused ? videoPlayer.play() : videoPlayer.pause(); }
        });

        function clickCh(ch) {
            const b = document.querySelector(`.channel-btn[data-channel="${ch}"]`);
            if (b) b.click();
        }
    </script>
</body>

</html>